<?php

/** @generate-class-entries */

namespace Teds;

/**
 * This exposes a similar API to Vector/LowMemoryVector, but for booleans instead of integers/bits.
 *
 * Benefits:
 *
 * - This is guaranteed to use less memory when serialized compared to vectors/arrays.
 * - Prevents using other value types
 *
 * @see https://en.wikipedia.org/wiki/Bit_array
 * @alias Teds\BitVector
 * (This alias will be removed in a future Teds release. Do not use it.)
 */
final class BitVector implements \IteratorAggregate, Sequence, \JsonSerializable
{
    /**
     * Construct a BitVector from an iterable of booleans.
     *
     * The keys will be ignored, and values will be reindexed without gaps starting from 0
     * @psalm-param iterator<bool> $iterator
     */
    public function __construct(iterable $iterator = []) {}
    /**
     * Returns an iterator that will return the indexes and bits of iterable until index >= count()
     */
    public function getIterator(): \InternalIterator {}
    /**
     * Returns the number of bits in this BitVector
     */
    public function count(): int {}
    /**
     * Returns whether this vector is empty (has a count of 0)
     */
    public function isEmpty(): bool {}
    /**
     * Returns the total capacity of this BitVector.
     */
    public function capacity(): int {}

    /** Returns an array containing the representation type used and a little-endian binary representation of the data. */
    public function __serialize(): array {}
    public function __unserialize(array $data): void {}

    /**
     * Returns a string containing the raw bits followed by a byte with the number of wasted bytes.
     * (or the empty string)
     *
     * This deliberately does not implement the deprecated Serializable interface.
     */
    public function serialize(): string {}

    /** Creates a BitVector from a string generated by BitVector::serialize() */
    public static function unserialize(string $data): BitVector {}

    /**
     * Returns the bytes of this bitset without a length indicator, filling in the last missing bits with 0
     */
    public function toBinaryString(): string {}
    /**
     * Creates a BitVector from raw bytes.
     * The resulting bitset will have count($bitVector) === strlen($data) * 8.
     */
    public static function fromBinaryString(string $data): BitVector {}

    /** Create this from an array */
    public static function __set_state(array $array): BitVector {}

    public function push(mixed ...$values): void {}
    /**
     * TODO: optimize unshift(), this is currently inefficient for varargs.
     */
    public function unshift(mixed ...$values): void {}
    /**
     * TODO: optimize insert(), this is currently inefficient for varargs.
     */
    public function insert(int $offset, mixed ...$values): void {}
    public function pushBits(bool ...$values): void {}

    /**
     * Returns the first bit of this bitset.
     * @throws \UnderflowException if there are no elements
     */
    public function first(): bool {}
    /**
     * Returns the last bit of this bitset.
     * @throws \UnderflowException if there are no elements
     */
    public function last(): bool {}

    /**
     * @throws \UnderflowException if there are no more elements
     */
    public function pop(): bool {}
    public function shift(): bool {}

    /** @psalm-return list<int> */
    public function toArray(): array {}
    /** @implementation-alias Teds\BitVector::toArray */
    public function values(): array {}
    public function clear(): void {}
    /**
     * Get the bit $offset bits from the start.
     *
     * Strictly typed, unlike offsetGet/offsetSet
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function get(int $offset): bool {}
    /**
     * Set the bit $offset bits from the start.
     *
     * Must be mixed $value to implement Sequence
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function set(int $offset, mixed $value): void {}

    public function setBit(int $offset, bool $value): void {}

    /**
     * Fetch the signed byte(int8) $offset *bytes* from the start (8 * $offset bits)
     * Integers are little-endian.
     *
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getInt8(int $offset): int {}
    /**
     * Fetch the usigned byte(uint8) $offset *bytes* from the start (8 * $offset bits)
     * Integers are little-endian.
     *
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getUInt8(int $offset): int {}
    /**
     * Set the signed byte(int8) $offset *bytes* from the start (8 * $offset bits)
     * The value will be silently truncated to ($value & 0xff)
     *
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function setInt8(int $offset, int $value): void {}

    /**
     * Fetch the signed int16 $offset *bytes* from the start (16 * $offset bits)
     * Integers are little-endian.
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getInt16(int $offset): int {}
    /**
     * Fetch the unsigned int16 $offset *bytes* from the start (16 * $offset bits)
     * Integers are little-endian.
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getUInt16(int $offset): int {}
    /**
     * Set the signed int16 $offset *bytes* from the start (16 * $offset bits)
     * The value will be silently truncated to ($value & 0xffff)
     *
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function setInt16(int $offset, int $value): void {}
    /**
     * Fetch the signed int32 $offset *bytes* from the start (32 * $offset bits)
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getInt32(int $offset): int {}
    /**
     * Fetch the unsigned int32 $offset *bytes* from the start (32 * $offset bits)
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function getUInt32(int $offset): int {}
    /**
     * Set the signed int32 $offset *bytes* from the start (32 * $offset bits)
     * The value will be silently truncated to ($value & 0xff)
     * Integers are little-endian.
     *
     * @throws \OutOfBoundsException if out of bounds.
     */
    public function setInt32(int $offset, int $value): void {}
    /**
     * Fetch the signed int64 $offset *bytes* from the start (64 * $offset bits).
     * Integers are little-endian.
     *
     * @throws \OutOfBoundsException if out of bounds.
     * @throws \Teds\UnsupportedOperationException on 32-bit builds
     */
    public function getInt64(int $offset): int {}
    /**
     * Set the signed int64 $offset *bytes* from the start (64 * $offset bits)
     * The value will be silently truncated to ($value & 0xffff)
     *
     * @throws \OutOfBoundsException if out of bounds.
     * @throws \Teds\UnsupportedOperationException on 32-bit builds
     */
    public function setInt64(int $offset, int $value): void {}

    /**
     * Returns the value at (int)$offset.
     * @psalm-param int $offset
     * @throws \OutOfBoundsException if the value of (int)$offset is not within the bounds of this vector
     */
    public function offsetGet(mixed $offset): mixed {}

    /**
     * Returns true if `0 <= (int)$offset && (int)$offset < $this->count().
     * @psalm-param int $offset
     */
    public function offsetExists(mixed $offset): bool {}
    /**
     * Returns true if `is_int($offset) && 0 <= $offset && $offset < $this->count().
     */
    public function containsKey(mixed $offset): bool {}

    /**
     * Sets the value at offset (int)$offset to $value
     * @psalm-param int $offset
     * @psalm-param bool $value
     * @throws \OutOfBoundsException if the value of (int)$offset is not within the bounds of this vector
     */
    public function offsetSet(mixed $offset, mixed $value): void {}

    /**
     * @throws \RuntimeException unconditionally because unset and null are different things.
     * Also, this can only contain booleans.
     */
    public function offsetUnset(mixed $offset): void {}

    /**
     * Returns the offset of a value that is === $value, or returns null.
     */
    public function indexOf(bool $value): ?int {}
    /**
     * Returns true if there exists an boolean === $value in this BitVector.
     */
    public function contains(mixed $value): bool {}

    /**
     * @implementation-alias Teds\BitVector::toArray
     */
    public function jsonSerialize(): array {}

    public function setSize(int $size, bool $default = false): void {}
}
